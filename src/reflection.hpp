#ifndef _b61286c5_ccd4_4f8b_b1fc_fd318d666f5e
#define _b61286c5_ccd4_4f8b_b1fc_fd318d666f5e

#include <array>
#include <cstdint>
#include <utility>
#include <iostream>
#include <tuple>
#include <type_traits>


////////////////////////////////////////////////////////////////////////
// reflection of class/struct members.

/* The easiest way to enable reflection for your class is:
 * 
 * struct my_type {
 *   int foo;
 *   float bar;
 *
 *   UPCXX_REFLECTED(foo, bar)
 * };
 */

namespace upcxx {
  namespace detail {
    template<typename Re, typename ...Ts>
    struct fold_reflected_help;

    template<typename Re>
    struct fold_reflected_help<Re> {
      Re operator()(Re re) const {
        return re;
      }
    };

    template<typename Re, typename T0, typename ...Ts>
    struct fold_reflected_help<Re,T0,Ts...> {
      auto operator()(Re re, T0 &&x0, Ts &&...xs) const ->
        decltype(
          fold_reflected_help<decltype(re & static_cast<T0&&>(x0)),Ts...>()
            (re & x0, static_cast<Ts&&>(xs)...)
        ) {
        return fold_reflected_help<decltype(re & static_cast<T0&&>(x0)),Ts...>()
          (re & x0, static_cast<Ts&&>(xs)...);
      }
    };

    template<typename Re, typename ...T>
    auto fold_reflected(Re re, T &&...x) ->
      decltype(fold_reflected_help<Re,T&&...>()(re, static_cast<T&&>(x)...)) {
      return fold_reflected_help<Re,T&&...>()(re, static_cast<T&&>(x)...);
    }
  }
  
  #define UPCXX_REFLECTED(...) \
    template<typename Re> \
    auto upcxx_reflected(Re re) -> \
      decltype(::upcxx::detail::fold_reflected(re, __VA_ARGS__)) { \
      return ::upcxx::detail::fold_reflected(re, __VA_ARGS__); \
    }
    
  // How to apply a reflector on a subject. May be specialized per type
  // but rarely is since default implementation finds a "upcxx_reflect"
  // member T.
  template<typename T, typename = void>
  struct reflection {
    static constexpr bool is_opaque = true;
    
    template<typename Re, typename T1>
    auto operator()(Re re, T1 &&me) const ->
      decltype(re.opaque(const_cast<T&>(me))) {
      return re.opaque(const_cast<T&>(me));
    }
  };

  struct nop_reflector {
    template<typename T>
    constexpr nop_reflector operator&(T&&) const { return *this; }
    template<typename T>
    constexpr nop_reflector opaque(T&&) const { return *this; }
  };

  template<typename T>
  struct reflection<T,
      typename std::conditional<true, void, decltype(std::declval<T&>().upcxx_reflected(nop_reflector{}))>::type
    > {
    static constexpr bool is_opaque = false;
    
    template<typename Re, typename T1>
    auto operator()(Re re, T1 &&me) const ->
      decltype(const_cast<T&>(me).upcxx_reflected(re)) {
      return const_cast<T&>(me).upcxx_reflected(re);
    }
  };

  // Invoke a reflector upon a subject object.
  template<typename Re, typename T,
           typename T0 = typename std::decay<T>::type>
  auto reflect_upon(Re re, T &&me) ->
    decltype(reflection<T0>()(re, std::forward<T>(me))) {
    return reflection<T0>()(re, std::forward<T>(me));
  }
}


////////////////////////////////////////////////////////////////////////
// Reflection based hashing

namespace upcxx {
  struct fast_hasher {
    std::size_t s;
    
    fast_hasher(std::size_t salt):
      s{salt} {
    }
    
    void operator()(std::size_t x) {
      /** Utilities derived from Boost, subject to the following license:

      Boost Software License - Version 1.0 - August 17th, 2003

      Permission is hereby granted, free of charge, to any person or organization
      obtaining a copy of the software and accompanying documentation covered by
      this license (the "Software") to use, reproduce, display, distribute,
      execute, and transmit the Software, and to prepare derivative works of the
      Software, and to permit third-parties to whom the Software is furnished to
      do so, all subject to the following:

      The copyright notices in the Software and this entire statement, including
      the above license grant, this restriction and the following disclaimer,
      must be included in all copies of the Software, in whole or in part, and
      all derivative works of the Software, unless such copies or derivative
      works are solely in the form of machine-executable object code generated by
      a source language processor.

      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
      SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
      FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
      ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
      DEALINGS IN THE SOFTWARE.
      */
      s ^= x + 0x9e3779b9 + (s<<6) + (s>>2);
    }
    
    std::size_t result() const {
      return s;
    }
  };
  
  template<typename Hasher>
  struct hasher_reflector {
    Hasher &h;
    
    template<typename T>
    hasher_reflector operator&(T const &x) const {
      return reflect_upon(*this, x);
    }
    
    template<typename T>
    hasher_reflector opaque(const T &x) const {
      h(std::hash<T>()(x));
      return *this;
    }
  };
  
  
  //////////////////////////////////////////////////////////////////////
  // fast_hashing: Drop-in for std::hash that uses reflection.
  
  template<typename T>
  struct fast_hashing {
    std::size_t operator()(const T &x, std::size_t salt=0) const {
      fast_hasher h{salt};
      reflect_upon(hasher_reflector<fast_hasher>{h}, x);
      return h.result();
    }
  };
  
  template<typename T>
  inline std::size_t fast_hash(const T &x, std::size_t salt=0) {
    return fast_hashing<T>()(x, salt);
  }

  //////////////////////////////////////////////////////////////////////
  // reflection<std::tuple>
  
  template<typename Tup, int i, int n>
  struct reflection_tuple {
    template<typename Re, typename Tup1>
    auto operator()(Re re, Tup1 &&x) const
      -> decltype(
        re(std::get<i>(x)) &
        reflection_tuple<Tup,i+1,n>()(re, static_cast<Tup1&&>(x))
      ) {
      return re(std::get<i>(x)) &
             reflection_tuple<Tup,i+1,n>()(re, static_cast<Tup1&&>(x));
    }
  };
  template<typename Tup, int n>
  struct reflection_tuple<Tup,n,n> {
    template<typename Re, typename Tup1>
    Re operator()(Re re, Tup1 &&x) const {
      return re;
    }
  };
  
  template<typename ...Ts>
  struct reflection<std::tuple<Ts...>> {
    template<typename Re, typename Tup1>
    auto operator()(Re re, Tup1 &&x) const
      -> decltype(
        reflection_tuple<std::tuple<Ts...>, 0, sizeof...(Ts)>()(re, static_cast<Tup1&&>(x))
      ) {
      return reflection_tuple<std::tuple<Ts...>, 0, sizeof...(Ts)>()(re, static_cast<Tup1&&>(x));
    }
  };
  
  
  //////////////////////////////////////////////////////////////////////
  // reflection<std::pair>
  
  template<typename A, typename B>
  struct reflection<std::pair<A,B>> {
    template<typename Re, typename Pair>
    auto operator()(Re re, Pair &&x) const
      -> decltype(re & x.first & x.second) {
      return re & x.first & x.second;
    }
  };
}


////////////////////////////////////////////////////////////////////////
// ostream& << upcxx::print(T): Reflection based iostream printing.

namespace upcxx {
  struct print_reflector {
    std::ostream &o;
    bool comma;
    
    template<typename T>
    print_reflector& opaque(const T &x) {
      if(comma) o << ',';
      comma = true;
      o << x;
      return *this;
    }
    template<typename T>
    print_reflector& operator()(const T &x) {
      return this->opaque(x);
    }
  };
  
  template<typename T>
  struct print_proxy {
    T const &subject;
    
    friend std::ostream& operator<<(std::ostream &o, print_proxy &me) {
      print_reflector re{o, false};
      o << '{';
      upcxx::reflect_upon(re, me.subject);
      o << '}';
      return o;
    }
  };
  
  template<typename T>
  inline print_proxy<T> print(T const &subject) {
    return print_proxy<T>{subject};
  }
}

#endif
